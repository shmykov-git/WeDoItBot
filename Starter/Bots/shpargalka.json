{
  "Rooms": [
    {
      "Id": "start",
      "AutoGo": "service"
    },
    {
      "Id": "service",
      "Menu": "Выберите вопрос",
      "Items": [
        {
          "Button": "🎩 Что такое GoF?",
          "Go": "GoF"
        },
        {
          "Button": "🎩 Что такое SOLID?",
          "Go": "solid"
        },
        {
          "Button": "🎩 Что такое IoC?",
          "Go": "IoC"
        },
        {
          "Button": "🎩 Что такое GRASP?",
          "Go": "GRASP"
        }
      ]
    },
    {
      "Id": "GoF",
      "Menu": "☠ Gang Of Four (Банда четырех) - команда авторов книги изданой в 1994 году. В ней приводятся паттерны разработки программного кода, которые актуальны по настоящее время. Популярность книги заложила унификацию в процесс проектирования ПО, упорядочило разработку, сформулировав ряд типовых задач. Позволило сообществу разработчиков говорить на общем языке проектирования кода - языке паттернов",
      "Items": [
        {
          "Button": "👑 Порождающие шаблоны проектирования",
          "Go": "GoF_create"
        },
        {
          "Button": "🍔 Структурные шаблоны проектирования",
          "Go": "GoF_struct"
        },
        {
          "Button": "🍃 Поведенческие шаблоны проектирования",
          "Go": "GoF_act"
        },
        {
          "Button": "◄",
          "Go": "service"
        }
      ]
    },
    {
      "Id": "GoF_create",
      "Menu": "👑 Шаблоны описывают механизмы создания объектов. Как будут создаваться объекты?",
      "Items": [
        {
          "Button": "🔸 Абстрактная фабрика",
          "Go": "GoF_create_afactory"
        },
        {
          "Button": "🔸 Строитель",
          "Go": "GoF_create_Builder"
        },
        {
          "Button": "🔸 Фабричный метод",
          "Go": "GoF_create_factorymethod"
        },
        {
          "Button": "🔸 Прототип",
          "Go": "GoF_create_Prototype"
        },
        {
          "Button": "🔸 Одиночка",
          "Go": "GoF_create_Singleton"
        },
        {
          "Button": "◄",
          "Go": "GoF"
        }
      ],
      "Col": "2"
    },
    {
      "Id": "GoF_create_afactory",
      "Say": "Предоставляет интерфейс для создания семейств объектов. Сегодня мало применим в силу тенденции упрощения систем (микросервисы), а также использования IoC",
      "Go": "GoF_create"
    },
    {
      "Id": "GoF_create_Builder",
      "Say": "Скрывает сложность создания объекта. Предоставляет широкие возможности по создания объекта. Отвечает за эффективность создания. Актуальный сегодня паттерн (пример: класс StringBuilder)",
      "Go": "GoF_create"
    },
    {
      "Id": "GoF_create_factorymethod",
      "Say": "Предоставляет интерфейс создания объекта 'параллельного семейства' объектов с помощью метода создателя расположенного в базовом класссе. Сегодня выглядит устаревшим, в силу развития отдельного фреймворка инициализации объектов (см. IoC). Однако сама идея инициализации объекта с помощью порождающего метода сегодня актуальна и является частью IoC парадигмы",
      "Go": "GoF_create"
    },
    {
      "Id": "GoF_create_Prototype",
      "Say": "Создает объект при помощи копирования заранее скопанованного объекта - прототипа. Используется например в JavaScript для создания новых объектов. В C#, как правило, нет (см. IoC)",
      "Go": "GoF_create"
    },
    {
      "Id": "GoF_create_Singleton",
      "Say": "Гарантирует, что в рамках приложения будет создан лиш один экземпляр данного класса. Бывает для одного потока, бывает для многих. Бывает ленивый, бывает нет. Ходят слухи, что он антипаттерн. Устарел в силу развития IoC. По факту нужен собственно для инициализации самого контейнера IoC, входит в состав IoC фреймворка как одна из стратегий порождения. Может быть более актуален в языках C++, не могу тут точно знать",
      "Go": "GoF_create"
    },
    {
      "Id": "GoF_struct",
      "Menu": "🍔 Шаблоны объединения классов (интерфейсов, объектов) в структуры. Как структурировать классы, что бы решить определенную типовую задачу?",
      "Items": [
        {
          "Button": "🔸 Адаптер",
          "Go": "GoF_create_adapter"
        },
        {
          "Button": "🔸 Мост",
          "Go": "GoF_create_Bridge"
        },
        {
          "Button": "🔸 Компоновщик",
          "Go": "GoF_create_composite"
        },
        {
          "Button": "🔸 Декоратор",
          "Go": "GoF_create_Decorator"
        },
        {
          "Button": "🔸 Фасад",
          "Go": "GoF_create_Facade"
        },
        {
          "Button": "🔸 Приспособленец",
          "Go": "GoF_create_Flyweight"
        },
        {
          "Button": "🔸 Заместитель",
          "Go": "GoF_create_proxy"
        },
        {
          "Button": "◄",
          "Go": "GoF"
        }
      ],
      "Col": "2"
    },
    {
      "Id": "GoF_create_adapter",
      "Say": "Интерфейс одного вида приводит к интерфейсу требуемого вида. Прост и востребован сегодня",
      "Go": "GoF_struct"
    },
    {
      "Id": "GoF_create_Bridge",
      "Say": "Позволяет независимо изменять как сам класс, так и логику его работы, вводя абстрактную реализацию последней. Ну вот этот бот реализует паттерн мост, чтобы абстрагироваться от системы его отображающей - Телеграм приложения. Т.е. телеграмм вполне можно заменить на другую систему отображения сообщений бота без изменения логики самого бота - это паттерн Мост",
      "Go": "GoF_struct"
    },
    {
      "Id": "GoF_create_composite",
      "Say": "Представляет объекты в виде дерева, позволяет работать с любой веткой и листом одинакого. Это дает высокую гибкость компоновки - выстраивания структуры объектов. Почти все UI представление сегодня работает именно так",
      "Go": "GoF_struct"
    },
    {
      "Id": "GoF_create_Decorator",
      "Say": "Динамически подключает дополнительное поведение к объекту. Частый пример: вызов метода обернут другим методом с дополнительными функциями, который уже сам вызывает исходный метод и возможно что-то еще делает уже с результатом работы последнего. Актуальность - да!",
      "Go": "GoF_struct"
    },
    {
      "Id": "GoF_create_Facade",
      "Say": "Делегирует одному объекту вызов методов всех подсистем. Скрывает сложность подсистем, унифицирует вызов, пожет определить политики вызова. Актуален для сложных систем",
      "Go": "GoF_struct"
    },
    {
      "Id": "GoF_create_Flyweight",
      "Say": "Решает задачу представления множества уникальных объектов для которых нужно съэкономить память путем использования псевдоуникальности. Актуален в играх, где восприятие не страдает на больших количествах, а вот памят нужно съэкономить",
      "Go": "GoF_struct"
    },
    {
      "Id": "GoF_create_proxy",
      "Say": "Перехватывает все вызовы к основному объекту, которого содержит в себе. Имеет дополнительную логику работы с запросами, которая например и обеспечивает возможность вызова методов основного объекта",
      "Go": "GoF_struct"
    },
    {
      "Id": "GoF_act",
      "Menu": "🍃 Шаблоны типовых алгоритмов. Как организовать взаимодействие классов, чтобы решить определенную типовую задачу?",
      "Items": [
        {
          "Button": "🔸 Цепочка обязанностей",
          "Go": "GoF_act_Chainofresponsibility"
        },
        {
          "Button": "🔸 Команда",
          "Go": "GoF_act_Command"
        },
        {
          "Button": "🔸 Интерпретатор",
          "Go": "GoF_act_Interpreter"
        },
        {
          "Button": "🔸 Итератор",
          "Go": "GoF_act_Iterator"
        },
        {
          "Button": "🔸 Посредник",
          "Go": "GoF_act_Mediator"
        },
        {
          "Button": "🔸 Хранитель",
          "Go": "GoF_act_Memento"
        },
        {
          "Button": "🔸 Наблюдатель",
          "Go": "GoF_act_Observer"
        },
        {
          "Button": "🔸 Состояние",
          "Go": "GoF_act_State"
        },
        {
          "Button": "🔸 Стратегия",
          "Go": "GoF_act_Strategy"
        },
        {
          "Button": "🔸 Шаблонный метод",
          "Go": "GoF_act_TemplateMethod"
        },
        {
          "Button": "🔸 Посетитель",
          "Go": "GoF_act_visitor"
        },
        {
          "Button": "◄",
          "Go": "GoF"
        }
      ],
      "Col": "2"
    },
    {
      "Id": "GoF_act_Chainofresponsibility",
      "Say": "Цепочка уровней на каждом из которых возможна обработка входящего сообщения, и/или делегирование обработки на уровень выше. Так например устроены многие современные обработчики UI сообщений.",
      "Go": "GoF_act"
    },
    {
      "Id": "GoF_act_Command",
      "Say": "Организует возможность обратного вызова, при этом выступает в качестве объекта данных, т.е. команду можно передать и выполнить вызов уже из внешней системы. Технологии биндинга данных активно используют этот паттерн",
      "Go": "GoF_act"
    },
    {
      "Id": "GoF_act_Interpreter",
      "Say": "'Интерпретатор языка C#' - как частный случай. Требуется постоянно по определенным правилам выполнять интерпретацию, результатом которой является набор метаданных известный как dll. В более общем случае интерпретатор решает любую задачу в которой что-то часто изменияется. Каждый раз есть какой-то результат интерпретации, который соответственно тоже меняется в зависимости от правил (контекста) интерпретатора",
      "Go": "GoF_act"
    },
    {
      "Id": "GoF_act_Iterator",
      "Say": "Предоставляет последовательный доступ к элементам объекта. Скрывает сложность перебора этих элементов. Можно например структуру дерева представить через итератор и сделать ее таким образом линейной, что удобно для простых операторов циклов",
      "Go": "GoF_act"
    },
    {
      "Id": "GoF_act_Mediator",
      "Say": "Скрывает связи между объектами предоствляя им возможность взаимодействовать только через посредника",
      "Go": "GoF_act"
    },
    {
      "Id": "GoF_act_Memento",
      "Say": "Позволяет сохранить и восстановить состояние объекта",
      "Go": "GoF_act"
    },
    {
      "Id": "GoF_act_Observer",
      "Say": "Реализует механизм регистрации других объектов, чтобы иметь возможность за ними наблюдать. Изменения таких объектов нотифицируют наблюдателя",
      "Go": "GoF_act"
    },
    {
      "Id": "GoF_act_State",
      "Say": "Есть набор состояний. Есть правила перехода от одного состояния к другому. Паттерн гарантирует, что переход осуществим только по прописанным правилам и гарантирует выполнение действий перехода только когда это возможно. Известен еще как конечный автомат",
      "Go": "GoF_act"
    },
    {
      "Id": "GoF_act_Strategy",
      "Say": "Позволяет выбрать алгоритм из семейства взаимозаменяемых алгоритмов",
      "Go": "GoF_act"
    },
    {
      "Id": "GoF_act_TemplateMethod",
      "Say": "Позволяет реализовать часть алгоритма - шаблон. Полный алгоритм получается путем подстановки недостающих частей - кусков исполняемого кода, как правило определенных в классах наследниках",
      "Go": "GoF_act"
    },
    {
      "Id": "GoF_act_visitor",
      "Say": "Позволяет не вносить изменения в набор посещаемых классов. При этом количество операций над семейством объектов визитора ограничено только количеством реализованных визиторов. Т.е. позволяет вынести логику работы с семейством классов в отдельные классы - визиторы, оставив сами классы в простом и понятном виде",
      "Go": "GoF_act"
    },
    {
      "Id": "solid",
      "Menu": "Это набор принципов разработки ПО",
      "Items": [
        {
          "Button": "Ⓢ",
          "Go": "solid_s"
        },
        {
          "Button": "Ⓞ",
          "Go": "solid_o"
        },
        {
          "Button": "Ⓛ",
          "Go": "solid_l"
        },
        {
          "Button": "Ⓘ",
          "Go": "solid_i"
        },
        {
          "Button": "Ⓓ",
          "Go": "solid_d"
        },
        {
          "Button": "◄",
          "Go": "service"
        }
      ],
      "Col": "6"
    },
    {
      "Id": "solid_s",
      "Say": "Single responsibility",
      "Go": "solid"
    },
    {
      "Id": "solid_o",
      "Say": "Open–closed",
      "Go": "solid"
    },
    {
      "Id": "solid_l",
      "Say": "Liskov substitution",
      "Go": "solid"
    },
    {
      "Id": "solid_i",
      "Say": "Interface segregation",
      "Go": "solid"
    },
    {
      "Id": "solid_d",
      "Say": "Dependency inversion",
      "Go": "solid"
    },
    {
      "Id": "IoC",
      "Menu": "Это принцип инверсии управления. Делегирование контроля выполнения кода отдельному фреймворку. Часто используется для выделения фреймворка создания объектов чем заменяет большое семейство порождающих паттернов GoF",
      "Items": [
        {
          "Button": "Ⓣ Табличка",
          "Go": "IoC_table"
        },
        {
          "Button": "☕ Разъяснялка",
          "Go": "IoC_text"
        },
        {
          "Button": "◄",
          "Go": "service"
        }
      ],
      "Col": "3"
    },
    {
      "Id": "IoC_table",
      "Say": "",
      "Go": "IoC"
    },
    {
      "Id": "IoC_text",
      "Say": "- Как бы нам сделать инверсию зависимостей?\n- А давайте сделаем инверсию управления.\n- А как?\n- Сделаем сервис, который сам будет создавать все объекты так, как ему нужно и будет их вставлять в каждую сущность, которая этого требует.\n- Так это получается инжекция зависимостей что ли?\n- Точно! Сервис инжектирует зависимости самостоятельно!\n- Погодите, но мы же делаем инверсию зависимостей?\n- Да!! Как только мы станем инжектить зависимости, то пропадёт зависимость от базовых сущностей в верхних модулях, это и называется инверсией зависимостей!",
      "Go": "IoC"
    },
    {
      "Id": "GRASP",
      "Menu": "GRASP (general responsibility assignment software patterns)\nКак правильно наделять классы той или иной ответственностью? - вот об этом данные принципы проектирования",
      "Items": [
        {
          "Button": "🔸 Information Expert",
          "Go": "GRASP_InformationExpert"
        },
        {
          "Button": "🔸 Creator",
          "Go": "GRASP_Creator"
        },
        {
          "Button": "🔸 Controller",
          "Go": "GRASP_Controller"
        },
        {
          "Button": "🔸 Low Coupling",
          "Go": "GRASP_LowCoupling"
        },
        {
          "Button": "🔸 High Cohesion",
          "Go": "GRASP_HighCohesion"
        },
        {
          "Button": "🔸 Polymorphism",
          "Go": "GRASP_Polymorphism"
        },
        {
          "Button": "🔸 Pure Fabrication",
          "Go": "GRASP_PureFabrication"
        },
        {
          "Button": "🔸 Indirection",
          "Go": "GRASP_Indirection"
        },
        {
          "Button": "🔸 Protected Variations",
          "Go": "GRASP_ProtectedVariations"
        },
        {
          "Button": "◄",
          "Go": "service"
        }
      ],
      "Col": "2"
    },
    {
      "Id": "GRASP_InformationExpert",
      "Say": "Information Expert\nИменно данный класс получил все требуемые данные - вот он и должен содержать методы работы с этими данными",
      "Go": "GRASP"
    },
    {
      "Id": "GRASP_Creator",
      "Say": "Creator\nПорождающий паттерн. Скрывает сложность создания объекта",
      "Go": "GRASP"
    },
    {
      "Id": "GRASP_Controller",
      "Say": "Controller\nРеализует функционал приема внешних запросов, делегирует их выполнение другим модулям",
      "Go": "GRASP"
    },
    {
      "Id": "GRASP_LowCoupling",
      "Say": "Low Coupling\nКласс реализован таким способом, что изменение внешних модулей (классов) слабо влияет или вовсе не влияет на его реализацию, т.е. класс не требуется переписывать при внешних изменениях",
      "Go": "GRASP"
    },
    {
      "Id": "GRASP_HighCohesion",
      "Say": "High Cohesion\nЭто аналог принципа single resposibility (SOLID) класса. Только немного в более широком смысле. Это оценка проекта в целом, на сколько каждый из классов завязан на выполнении конкретной специфичной функции. Чем выше связанность, тем понятнее система",
      "Go": "GRASP"
    },
    {
      "Id": "GRASP_Polymorphism",
      "Say": "Polymorphism\nСпособность системы к сложной адаптации. Много внешних факторов, они меняются и нужно поддреживать данную систему в актуальном незапутанном виде (Отчеты в Excel соответствуют этому принципы. Любой отчет делается на 4-8 часов, потому что заложена сложная адаптация, или данная платформа для ботов - 3 часа и новый бот)",
      "Go": "GRASP"
    },
    {
      "Id": "GRASP_PureFabrication",
      "Say": "Pure Fabrication\nПозволяет в сложных случаях \"придумать\" абстракцию которой может не быть в реальности, наделить ее частью функций. Тем самым разгрузить какие-то перегруженные классы",
      "Go": "GRASP"
    },
    {
      "Id": "GRASP_Indirection",
      "Say": "Indirection\nПосредник. Есть класс отвечающий за промежуточную логику работы других классов.\nНапример Model-View-Controller - тут контроллер позволяет модели и представлению не знать ничего друг о друге.\nМодель занята только своей внутренней логикой - что происходит в системе.\nПредставление - умеет отображать любые данные, которые ей предоставят.\nКонтроллер берет конктретную модель, делает адаптацию данных под конкретное представление.\nВот этот вот функционал посредника в данной системе паттернов называется Indirection.",
      "Go": "GRASP"
    },
    {
      "Id": "GRASP_ProtectedVariations",
      "Say": "Protected Variations\nВсе возможные изменения системы определяются через публичный интерфейс (В отчетах есть интерфейс контекста, который определяет, что именно можно делать при создании отчета) - это протекция системы отчетов от некорректных изменений",
      "Go": "GRASP"
    }
  ]
}